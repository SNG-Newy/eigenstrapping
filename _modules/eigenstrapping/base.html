

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>eigenstrapping.base &mdash; eigenstrapping 0.0.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=ccc4b35e" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=c1dcd045"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            eigenstrapping
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Reference API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">eigenstrapping</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">eigenstrapping.base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for eigenstrapping.base</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Eigenmode resampling on the cortex</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_get_eigengroups</span><span class="p">,</span>
    <span class="n">eigen_decomposition</span><span class="p">,</span>
    <span class="n">transform_to_spheroid</span><span class="p">,</span>
    <span class="n">transform_to_ellipsoid</span><span class="p">,</span>
    <span class="n">normalize_data</span><span class="p">,</span>
    <span class="p">)</span>

<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">from</span> <span class="nn">.geometry</span> <span class="kn">import</span> <span class="p">(</span><span class="n">calc_surface_eigenmodes</span><span class="p">,</span> 
                       <span class="n">get_tkrvox2ras</span><span class="p">,</span>
                       <span class="n">make_tetra</span><span class="p">,</span>
                       <span class="n">spin_single</span><span class="p">,</span>
                       <span class="n">gen_eigensamples</span><span class="p">,</span>
                       <span class="n">truncate_emodes</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">nilearn</span> <span class="kn">import</span> <span class="n">plotting</span><span class="p">,</span> <span class="n">masking</span>
<span class="kn">from</span> <span class="nn">.dataio</span> <span class="kn">import</span> <span class="n">is_string_like</span><span class="p">,</span> <span class="n">dataio</span><span class="p">,</span> <span class="n">load_surface</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.validation</span> <span class="kn">import</span> <span class="n">check_random_state</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">normaltest</span>
<span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="kn">from</span> <span class="nn">lapy</span> <span class="kn">import</span> <span class="n">TetMesh</span><span class="p">,</span> <span class="n">Solver</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">griddata</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">.rotations</span> <span class="kn">import</span> <span class="n">rotate_matrix</span>

<span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>

<span class="n">norm_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">,</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;number&#39;</span><span class="p">]</span>

<span class="k">global</span> <span class="n">methods</span>
<span class="n">methods</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;matrix&#39;</span><span class="p">,</span>
    <span class="s1">&#39;regression&#39;</span><span class="p">,</span>
    <span class="p">]</span>

<span class="k">def</span> <span class="nf">eigengroup_wavelength</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">60.0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the approximate wavelength of a mode given a radius of the surface</span>
<span class="sd">    (radii are approximated for non-spherical surfaces, default 60mm). Radius is </span>
<span class="sd">    specified in mm. Based on the degenerate solution of the Laplace-Beltrami</span>
<span class="sd">    operator on a sphere in [1]:</span>
<span class="sd">        </span>
<span class="sd">                        2 * pi * radius</span>
<span class="sd">        wavelength ~= -------------------</span>
<span class="sd">                      [ l ( l + 1 ) ] ^ 2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mode : int</span>
<span class="sd">        Mode at which to return the (approximate) wavelength.</span>
<span class="sd">    radius : float, default 60.0</span>
<span class="sd">        The (approximate) radius of the surface, measured in millimeters.</span>
<span class="sd">    group : bool, default False</span>
<span class="sd">        Return the group membership of `mode`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Approximate wavelength of `mode` in mm.</span>
<span class="sd">    if group is True: int</span>
<span class="sd">        Group membership of `mode`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input mode must be an integer zero or greater&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Wavelength of zeroth mode is infinity.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">group</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">l</span>
    
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">total</span> <span class="o">&lt;</span> <span class="n">mode</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="n">wavelength</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">/</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  
    <span class="k">if</span> <span class="n">group</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">l</span><span class="p">,</span> <span class="n">wavelength</span>
    
    <span class="k">return</span> <span class="n">wavelength</span>

<span class="k">def</span> <span class="nf">compute_psd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emodes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute normalized power spectral density using emodes.&quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">eigen_decomposition</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">],</span> <span class="n">emodes</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">])</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">normalized_power</span> <span class="o">=</span> <span class="n">power</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">normalized_power</span>

<span class="k">def</span> <span class="nf">gram_schmidt_randomized</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">rs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Orthogonalize a set of vectors stored as the columns of matrix A.</span>
<span class="sd">    Randomize the order of orthonormalization to explore different parameter</span>
<span class="sd">    spaces.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get the number of vectors</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># Randomize the column order</span>
    <span class="k">if</span> <span class="n">rs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>
    <span class="n">random_order</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    
    <span class="n">B</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">[:,</span> <span class="n">random_order</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># To orthogonalize the vector in column j with respect to the</span>
        <span class="c1"># previous vectors, subtract from it its projection onto</span>
        <span class="c1"># each of the previous vectors</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
            <span class="n">B</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">[:,</span> <span class="n">k</span><span class="p">],</span> <span class="n">B</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">*</span><span class="n">B</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span>
        
        <span class="n">B</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">B</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
        
    <span class="c1"># reverse the randomization to original order</span>
    <span class="n">reverse_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">random_order</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">B</span><span class="p">[:,</span> <span class="n">reverse_order</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">A</span>

<span class="k">def</span> <span class="nf">is_gaussian_distribution</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">significance_level</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the given data matches a Gaussian distribution using a normality test.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data (array-like): The data to be tested.</span>
<span class="sd">        significance_level (float, optional): The significance level for the test. Default is 0.05.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if the data is consistent with a Gaussian distribution, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">data</span> <span class="o">=</span> <span class="n">normalize_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">p_value</span> <span class="o">=</span> <span class="n">normaltest</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p_value</span> <span class="o">&gt;=</span> <span class="n">significance_level</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="SurfaceEigenstrapping"><a class="viewcode-back" href="../../generated/eigenstrapping.SurfaceEigenstrapping.html#eigenstrapping.SurfaceEigenstrapping">[docs]</a><span class="k">class</span> <span class="nc">SurfaceEigenstrapping</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the eigenmodes and eigenvalues of the surface in `surface` and </span>
<span class="sd">    resample the hypersphere bounded by the eigengroups contained within `emodes`,</span>
<span class="sd">    to reconstruct the data using coefficients conditioned on the original data</span>
<span class="sd">    Based on the degenerate solutions of solving the Laplace-Beltrami operator </span>
<span class="sd">    on the cortex. The power spectrum is perfectly retained (the square of the </span>
<span class="sd">    eigenvalues). If evals and emodes are given (i.e., precomputed) then </span>
<span class="sd">    eigenmodes are not computed. Performs amplitude adjustment by default (see</span>
<span class="sd">    `resample`)</span>
<span class="sd">    </span>
<span class="sd">    @author: Nikitas C. Koussis, School of Psychological Sciences,</span>
<span class="sd">             University of Newcastle &amp; Systems Neuroscience Group Newcastle</span>
<span class="sd">             </span>
<span class="sd">             Michael Breakspear, School of Psychological Sciences,</span>
<span class="sd">             University of Newcastle &amp; Systems Neuroscience Group Newcastle</span>
<span class="sd">    </span>
<span class="sd">    Process</span>
<span class="sd">    -------</span>
<span class="sd">        - the orthonormal eigenvectors n within eigengroup l give the surface </span>
<span class="sd">            of the hyperellipse of dimensions l-1</span>
<span class="sd">            NOTE: for eigengroup 0 with the zeroth mode, we ignore it,</span>
<span class="sd">            and for eigengroup 1, this is resampling the surface of the </span>
<span class="sd">            2-sphere</span>
<span class="sd">        - the axes of the hyperellipse are given by the sqrt of the eigenvalues </span>
<span class="sd">            corresponding to eigenvectors n</span>
<span class="sd">        - linear transform the eigenvectors N to the hypersphere by dividing </span>
<span class="sd">            by the ellipsoid axes</span>
<span class="sd">        - finds the set of points `p` on the hypersphere given by the basis </span>
<span class="sd">            modes (the eigenmodes) by normalizing them to unit length</span>
<span class="sd">        - rotate the set of points `p` by cos(angle) for </span>
<span class="sd">            even dimensions and sin(angle) for odd dims (resampling step)</span>
<span class="sd">        - find the unit vectors of the points `p` by dividing by the </span>
<span class="sd">            Euclidean norm (equivalent to the eigenmodes)</span>
<span class="sd">        - make the new unit vectors orthonormal using Gram-Schmidt process</span>
<span class="sd">        - return the new eigenmodes of that eigengroup until all eigengroups</span>
<span class="sd">            are computed</span>
<span class="sd">        - reconstruct the null data by multiplying the original coefficients</span>
<span class="sd">            by the new eigenmodes</span>
<span class="sd">        - resamples the null data by performing rank-ordering to replicate</span>
<span class="sd">            the reconstructed data term, then adds the noise term back into the</span>
<span class="sd">            null data to produce a surrogate that replicates the original</span>
<span class="sd">            variance of the empirical data.</span>
<span class="sd">            * Only performed if `resample` = True.</span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">        1. Robinson, P. A. et al., (2016), Eigenmodes of brain activity: Neural field </span>
<span class="sd">        theory predictions and comparison with experiment. NeuroImage 142, 79-98.</span>
<span class="sd">        &lt;https://dx.doi.org/10.1016/j.neuroimage.2016.04.050&gt;</span>
<span class="sd">        </span>
<span class="sd">        2. Jorgensen, M., (2014), Volumes of n-dimensional spheres and ellipsoids. </span>
<span class="sd">        &lt;https://www.whitman.edu/documents/Academics/Mathematics/2014/jorgenmd.pdf&gt;</span>
<span class="sd">        </span>
<span class="sd">        3. &lt;https://math.stackexchange.com/questions/3316373/ellipsoid-in-n-dimension&gt;</span>
<span class="sd">        </span>
<span class="sd">        4. Blumenson, L. E. (1960). A derivation of n-dimensional spherical </span>
<span class="sd">        coordinates. The American Mathematical Monthly, 67(1), 63-66.</span>
<span class="sd">        &lt;https://www.jstor.org/stable/2308932&gt;</span>
<span class="sd">        </span>
<span class="sd">        5. Trefethen, Lloyd N., Bau, David III, (1997). Numerical linear algebra. </span>
<span class="sd">        Philadelphia, PA: Society for Industrial and Applied Mathematics. </span>
<span class="sd">        ISBN 978-0-898713-61-9.</span>
<span class="sd">        </span>
<span class="sd">        6. https://en.wikipedia.org/wiki/QR_decomposition</span>
<span class="sd">        </span>
<span class="sd">        7. Chen, Y. C. et al., (2022). The individuality of shape asymmetries </span>
<span class="sd">        of the human cerebral cortex. Elife, 11, e75056. </span>
<span class="sd">        &lt;https://doi.org/10.7554/eLife.75056&gt;</span>
<span class="sd">        </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    surface : str of path to file or array_like</span>
<span class="sd">        Filename of surface to resample of surface.darrays[0].data of shape (n_vertices, 3)</span>
<span class="sd">        and surface.darrays[1].data of shape (n_faces, 3). Must be a single</span>
<span class="sd">        hemisphere or bounded surface.</span>
<span class="sd">        </span>
<span class="sd">    data : str of path to file or np.ndarray of (n_vertices,)</span>
<span class="sd">        Filename of empirical data to resample</span>
<span class="sd">        </span>
<span class="sd">    evals : np.ndarray of shape (n,), optional</span>
<span class="sd">        Eigenvalues corresponding to the number of eigenmodes n in `emodes`</span>
<span class="sd">        </span>
<span class="sd">    emodes : np.ndarray of shape (n_vertices, n), optional</span>
<span class="sd">        Eigenmodes that are the solution to the generalized eigenvalue problem</span>
<span class="sd">        or Helmholtz equation in the Laplace-Beltrami operator of the cortex</span>
<span class="sd">        </span>
<span class="sd">    num_modes : int, optional</span>
<span class="sd">        If `evals` and `emodes` are not given, then they are computed on the</span>
<span class="sd">        surface given in `surface`. This variable controls how many modes</span>
<span class="sd">        to compute. Cannot exceed the number of vertices in `surface`.</span>
<span class="sd">        Default is 200.</span>
<span class="sd">    </span>
<span class="sd">    medial : np.logical_array or str of path to file, default None</span>
<span class="sd">        Medial wall mask for the input surface `surface`. Suitable only if</span>
<span class="sd">        surface is cortical hemisphere. Will use the labels for the medial </span>
<span class="sd">        wall to mask out of the surrogates. If None, uses the naive </span>
<span class="sd">        implementation of finding the medial wall by finding 0.0 values</span>
<span class="sd">        in `data` - prone to errors if `data` has zero values outside of the</span>
<span class="sd">        medial wall. Can also pass `False` to not attempt masking of medial wall</span>
<span class="sd">        at all. </span>
<span class="sd">        </span>
<span class="sd">        WARNING: If passing `False` to medial and `True` to resample,</span>
<span class="sd">        resulting surrogates may have strange distributions since the </span>
<span class="sd">        rank-ordering step may assign medial-wall values outside of the </span>
<span class="sd">        medial wall. USE AT YOUR OWN RISK.</span>
<span class="sd">        </span>
<span class="sd">    save_surface : bool, optional</span>
<span class="sd">        As above, if `evals` and `emodes` are computed and medial wall mask</span>
<span class="sd">        is given, then cortical surface with cuts is saved. Default False.</span>
<span class="sd">    </span>
<span class="sd">    seed : None or int or np.random.RandomState instance</span>
<span class="sd">        Specify the seed for random angle generation (or random state instance)</span>
<span class="sd">        default None.</span>
<span class="sd">        </span>
<span class="sd">    decomp_method : str, optional</span>
<span class="sd">        method of calculation of coefficients: &#39;matrix&#39;, &#39;matrix_separate&#39;, </span>
<span class="sd">        &#39;regression&#39;.</span>
<span class="sd">        </span>
<span class="sd">        The default is &#39;matrix&#39;.</span>
<span class="sd">        </span>
<span class="sd">    resample : bool, optional</span>
<span class="sd">        Set whether to resample surrogate map from original map to preserve</span>
<span class="sd">        values, default True</span>
<span class="sd">        </span>
<span class="sd">    randomize : bool, optional</span>
<span class="sd">        Set whether to shuffle coefficients calculated from minimizing</span>
<span class="sd">        least-squares error to reconstruct surrogates. Results in better</span>
<span class="sd">        randomization of surrogates at the cost of poorer replication of</span>
<span class="sd">        empirical spatial autocorrelation.</span>
<span class="sd">    </span>
<span class="sd">    find_optimal : bool, optional</span>
<span class="sd">        Overrides `evals` and `emodes` if &quot;True&quot;. Computes a large amount</span>
<span class="sd">        of modes (20% of all possible modes of surface) and finds the optimal</span>
<span class="sd">        number of modes to make residual error between least-squares error</span>
<span class="sd">        estimation of coefficients and empirical data &quot;white&quot; (Gaussian),</span>
<span class="sd">        then generates new residuals with the same variance structure.</span>
<span class="sd">        Can increase computation time significantly but results in best balance</span>
<span class="sd">        of empirical variogram and randomization of values.</span>
<span class="sd">    </span>
<span class="sd">    n_jobs : int, optional</span>
<span class="sd">        Number of workers to use for parallelization. Default 1.</span>
<span class="sd">        </span>
<span class="sd">    use_cholmod : bool, optional</span>
<span class="sd">        Specify whether or not to use sksparse subroutines - requires </span>
<span class="sd">        ``scikit-sparse`` and ``libsuitesparse-dev`` to be installed. See </span>
<span class="sd">        https://github.com/scikit-sparse/scikit-sparse for more information.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError : Inappropriate inputs</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">evals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">emodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_modes</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
                 <span class="n">save_surface</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decomp_method</span><span class="o">=</span><span class="s1">&#39;matrix&#39;</span><span class="p">,</span>
                 <span class="n">medial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">randomize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                 <span class="n">use_cholmod</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">permute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">add_res</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">truncate_modes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ret_fwhm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">truncate_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">save_rotations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parcellation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_nn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nn_method</span><span class="o">=</span><span class="s1">&#39;original&#39;</span><span class="p">,</span> 
                 <span class="n">eigen_perms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="c1"># initialization of variables</span>
        <span class="k">if</span> <span class="n">surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No surface given, expecting precomputed eigenvalues and eigenmodes&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">evals</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">emodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Class must have a `surface` input, or eigenvalues `evals` and eigenmodes `emodes`&quot;</span><span class="p">)</span>        
        
        <span class="k">if</span> <span class="n">surface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_string_like</span><span class="p">(</span><span class="n">surface</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input surface must be a filename&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_file</span> <span class="o">=</span> <span class="n">surface</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">=</span> <span class="n">load_surface</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_file</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dataio</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">emodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">evals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[:</span><span class="n">num_modes</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span> <span class="o">=</span> <span class="n">emodes</span><span class="p">[:,</span> <span class="p">:</span><span class="n">num_modes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">num_modes</span> <span class="o">=</span> <span class="n">num_modes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_surface</span> <span class="o">=</span> <span class="n">save_surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rs</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decomp_method</span> <span class="o">=</span> <span class="n">decomp_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">medial</span> <span class="o">=</span> <span class="n">medial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resample</span> <span class="o">=</span> <span class="n">resample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span> <span class="o">=</span> <span class="n">randomize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cholmod</span> <span class="o">=</span> <span class="n">use_cholmod</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">permute</span> <span class="o">=</span> <span class="n">permute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_rotations</span> <span class="o">=</span> <span class="n">save_rotations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parcellation</span> <span class="o">=</span> <span class="n">parcellation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">truncate_modes</span> <span class="o">=</span> <span class="n">truncate_modes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_nn</span> <span class="o">=</span> <span class="n">use_nn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nn_method</span> <span class="o">=</span> <span class="n">nn_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eigen_perms</span> <span class="o">=</span> <span class="n">eigen_perms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">truncate_args</span> <span class="o">=</span> <span class="n">truncate_args</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_lm</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">(</span><span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_res</span> <span class="o">=</span> <span class="n">add_res</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">permute</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_res</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_res</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Permuting of residuals passed, `add_res` not passed&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp_method</span> <span class="ow">in</span> <span class="n">methods</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp_method</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Eigenmode decomposition method must be &#39;matrix&#39; or &#39;regression&#39;&quot;</span><span class="p">)</span>
        
        <span class="c1"># mask out medial wall</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">medial</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># get index of medial wall hopefully</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">medial_wall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">medial</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeWarning</span><span class="p">(</span><span class="s2">&quot;Resampling without masking out the medial wall &quot;</span>
                                     <span class="s2">&quot;may result in erroneous surrogate distributions. &quot;</span>
                                     <span class="s2">&quot;The authors of this code do not take responsibility for &quot;</span>
                                     <span class="s2">&quot;improper usage.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                     <span class="s2">&quot;USE AT YOUR OWN RISK.&quot;</span><span class="p">)</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">medial_wall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span> <span class="c1"># if given medial array</span>
            <span class="k">if</span> <span class="n">is_string_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medial</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">medial</span> <span class="o">=</span> <span class="n">dataio</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medial</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Could not load medial wall file, please check&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medial</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">medial</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Medial wall array must be a vector&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">medial</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vertices</span><span class="p">:</span>
                    <span class="c1"># try transpose</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">medial</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vertices</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Medial wall array must have the same number of vertices as the brain map&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">medial_wall</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medial</span><span class="o">.</span><span class="n">T</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medial</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medial</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Medial wall array must be 1 for the ROI (medial wall) and 0 elsewhere&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>    
                    <span class="bp">self</span><span class="o">.</span><span class="n">medial_wall</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medial</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not use provided medial wall array or &quot;</span>
                                 <span class="s2">&quot;file, please check&quot;</span><span class="p">)</span>
        
        <span class="c1"># checks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evals</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computing eigenmodes on surface using N=</span><span class="si">{</span><span class="n">num_modes</span><span class="si">}</span><span class="s1"> modes&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_modes</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vertices</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of modes must not exceed the number of vertices in input surface&#39;</span><span class="p">)</span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span> <span class="o">=</span> <span class="n">calc_surface_eigenmodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medial_wall</span><span class="p">,</span> <span class="n">save_cut</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_modes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_modes</span><span class="p">,</span> <span class="n">use_cholmod</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cholmod</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># perform checks</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Eigenvalue array must be 1-dimensional&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># try transpose</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span><span class="o">.</span><span class="n">T</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There must be as many eigenmodes as there are eigenvalues&quot;</span><span class="p">)</span>
        
        <span class="c1"># actually the indices that AREN&#39;T medial wall</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">medial_wall</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medial_wall</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="c1"># actually ARE the indices of medial wall</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">medial_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medial_wall</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data_no_mwall</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="c1"># deepcopy original data so it&#39;s not modified</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_no_mwall</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">medial_wall</span><span class="p">]</span>

        <span class="c1"># truncate eigenmodes at nearest eigengroup</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncate_modes</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;in order to compute kernel density estimate for data re:</span><span class="se">\n</span><span class="s1">&#39;</span>
                                 <span class="s1">&#39;number of modes (groups) to use, surface geometry must be given.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="n">truncate_emodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_no_mwall</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">medial_wall</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rs</span><span class="p">,</span> <span class="n">ret_fwhm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ret_fwhm</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">truncate_args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">medial_wall</span><span class="p">]</span>
        
        <span class="c1"># try initial modes given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigen_decomposition</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstructed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstructed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstructed_data</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_no_mwall</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstructed_data</span>
        
        <span class="c1"># compute original modal PSD</span>
        <span class="c1">#self.psd = compute_psd(self.data_no_mwall, self._emodes)</span>
        
        <span class="c1"># find eigengroups</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">_get_eigengroups</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate new surrogate map(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, default 1</span>
<span class="sd">            Number of surrogate maps to generate</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (n,N) np.ndarray</span>
<span class="sd">            Generated map(s) resampled from eigenspace of surface map</span>
<span class="sd">            </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Surrogates are returned with nans in place of the mask given by</span>
<span class="sd">        ``self.medial_wall``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rs</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_nn</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigen_perms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigen_perms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eigen_perms</span> <span class="o">=</span> <span class="n">gen_eigensamples</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">medial_wall</span><span class="p">,</span> <span class="n">num_modes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_modes</span><span class="p">,</span>
                                                <span class="n">n_rotate</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nn_method</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">surrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">(</span>
            <span class="n">Parallel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)(</span>
                    <span class="n">delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_call_method</span><span class="p">)(</span><span class="n">rs</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rs</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">surrs</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
    
    <span class="k">def</span> <span class="nf">_call_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Subfunction &quot;&quot;&quot;</span>
        
        <span class="c1"># reset randomstate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rs</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>
        
        <span class="n">surrogate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">surrogate</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    
<div class="viewcode-block" id="SurfaceEigenstrapping.generate"><a class="viewcode-back" href="../../generated/eigenstrapping.SurfaceEigenstrapping.html#eigenstrapping.SurfaceEigenstrapping.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_modes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate eigensphere resampled surrogate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        surrogate_data : np.ndarray</span>
<span class="sd">            Eigensphere resampled surrogate</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># initialize data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_no_mwall</span><span class="p">)</span>
        <span class="n">emodes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span><span class="p">)</span>
        <span class="n">evals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evals</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">medial_wall</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">)</span>
        <span class="n">reconstructed_data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reconstructed_data</span><span class="p">)</span>
        <span class="c1">#residuals = copy.deepcopy(self.residuals)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigen_perms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># initialize the new modes</span>
            <span class="n">new_modes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">emodes</span><span class="p">)</span>
            <span class="c1"># resample the hypersphere (except for groups 1 and 2)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="n">gen</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">group_modes</span> <span class="o">=</span> <span class="n">emodes</span><span class="p">[:,</span> <span class="n">groups</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
                <span class="n">group_evals</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">groups</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">group_modes</span>
                <span class="c1"># else, transform to spheroid and index the angles properly</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">transform_to_spheroid</span><span class="p">(</span><span class="n">group_evals</span><span class="p">,</span> <span class="n">group_modes</span><span class="p">)</span>
                
                <span class="n">p_rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_modes</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">gen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                
                <span class="c1"># transform back to ellipsoid</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">:</span>
                    <span class="n">p_rot</span> <span class="o">=</span> <span class="n">transform_to_ellipsoid</span><span class="p">(</span><span class="n">group_evals</span><span class="p">,</span> <span class="n">p_rot</span><span class="p">)</span>
                
                <span class="n">new_modes</span><span class="p">[:,</span> <span class="n">groups</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p_rot</span>
            
            <span class="k">if</span> <span class="n">output_modes</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">new_modes</span>            
        
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_modes</span> <span class="o">=</span> <span class="n">spin_single</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span><span class="p">,</span> 
                <span class="n">evals</span><span class="p">,</span> 
                <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> 
                <span class="n">eigen_perms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eigen_perms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_rs</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigen_perms</span><span class="p">))],</span>
                <span class="n">num_modes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_modes</span><span class="p">,</span>
                <span class="n">return_masked</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="c1"># matrix multiply the estimated coefficients by the new modes</span>
        <span class="n">surrogate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># original data</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)):</span>
                <span class="n">coeffs</span><span class="p">[</span><span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rs</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        
        <span class="c1"># adjust weights based on matching the power spectral density of</span>
        <span class="c1"># the original data</span>
        <span class="n">surrogate</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeffs</span> <span class="o">@</span> <span class="n">new_modes</span><span class="o">.</span><span class="n">T</span>
            
        <span class="c1"># Mask the data and surrogate_data excluding the medial wall</span>
        <span class="n">surr_no_mwall</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">surrogate</span><span class="p">)</span>
        <span class="n">surr_no_mwall</span> <span class="o">=</span> <span class="n">surr_no_mwall</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            
        <span class="c1"># if self.resample:</span>
        <span class="c1">#     # Get the rank ordered indices</span>
        <span class="c1">#     data_ranks = data.argsort()[::-1]</span>
        <span class="c1">#     surr_ranks = surr_no_mwall.argsort()[::-1]</span>
            
        <span class="c1">#     # Resample surr_no_mwall according to the rank ordering of data_no_mwall</span>
        <span class="c1">#     surr_no_mwall[surr_ranks] = data[data_ranks]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">:</span>  <span class="c1"># resample values from empirical map</span>
            <span class="n">sorted_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">surr_no_mwall</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">surr_no_mwall</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">sorted_map</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># force match the minimum and maximum</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">surr_no_mwall</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">surr_no_mwall</span><span class="p">))</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">sf</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">surr_no_mwall</span><span class="p">)</span>
            <span class="n">surr_no_mwall</span> <span class="o">=</span> <span class="n">surr_no_mwall</span> <span class="o">*</span> <span class="n">sf</span> <span class="o">+</span> <span class="n">shift</span>
        
        <span class="c1"># now add the residuals of the original data</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">surr_no_mwall</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">permute</span><span class="p">:</span>
            <span class="n">surr_no_mwall</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rs</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_res</span><span class="p">:</span>
            <span class="n">surr_no_mwall</span> <span class="o">+=</span> <span class="n">residuals</span>

        <span class="c1"># else: # force match the minima</span>
        <span class="c1">#     indices = np.nonzero(surr_no_mwall)[0]  # Indices where s is non-zero</span>

        <span class="c1">#     # Compute the normalization</span>
        <span class="c1">#     data_selected = data[indices]</span>
        <span class="c1">#     surr_selected = surr_no_mwall[indices]</span>
            
        <span class="c1">#     surr_no_mwall[indices] = (surr_selected - surr_selected.min()) * (data_selected.max() - data_selected.min()) / (surr_selected.max() - surr_selected.min()) + data_selected.min()</span>

        <span class="n">output_surr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">surrogate</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">output_surr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">surr_no_mwall</span>
        
        <span class="k">return</span> <span class="n">output_surr</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="SurfaceEigenstrapping.eigen_decomposition"><a class="viewcode-back" href="../../generated/eigenstrapping.SurfaceEigenstrapping.html#eigenstrapping.SurfaceEigenstrapping.eigen_decomposition">[docs]</a>    <span class="k">def</span> <span class="nf">eigen_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;matrix&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decompose data using eigenmodes and calculate the coefficient of </span>
<span class="sd">        contribution of each vector.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        method : string</span>
<span class="sd">            method of calculation of coefficients: &#39;matrix&#39;, &#39;matrix_separate&#39;, </span>
<span class="sd">            &#39;regression&#39;</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        coeffs : numpy array of shape (N, 3)</span>
<span class="sd">         coefficient values</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parcellation</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eigen_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_no_mwall</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;regression&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">eigen_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_no_mwall</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>
    
    <span class="k">def</span> <span class="nf">shuffle_modes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emodes</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rs</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">emodes</span><span class="p">)</span>
    
<div class="viewcode-block" id="SurfaceEigenstrapping.rotate_modes"><a class="viewcode-back" href="../../generated/eigenstrapping.SurfaceEigenstrapping.html#eigenstrapping.SurfaceEigenstrapping.rotate_modes">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_modes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emodes</span><span class="p">,</span> <span class="n">gen</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate modes using random rotations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vectors : np.ndarray of (n_vertices, mu)</span>
<span class="sd">            Orthogonal vectors of n_vertices and mu modes</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotated_vectors : np.ndarray of (n_vertices, mu)</span>
<span class="sd">            Array containing rotated vectors for each pair.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">gen</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rotate_matrix</span><span class="p">(</span><span class="n">emodes</span><span class="p">)</span>
        
        <span class="n">mu</span> <span class="o">=</span> <span class="n">emodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mu</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">mu</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rotate_matrix</span><span class="p">(</span><span class="n">emodes</span><span class="p">)</span>
        
        <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">emodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loader</span><span class="o">.</span><span class="n">get_random_rotation</span><span class="p">(</span><span class="n">l</span><span class="p">))</span></div>
        
<div class="viewcode-block" id="SurfaceEigenstrapping.resample_eigenspace"><a class="viewcode-back" href="../../generated/eigenstrapping.SurfaceEigenstrapping.html#eigenstrapping.SurfaceEigenstrapping.resample_eigenspace">[docs]</a>    <span class="k">def</span> <span class="nf">resample_eigenspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emodes</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample across the eigenspace through linear weighted sums of real</span>
<span class="sd">        modes iteratively. Each iteration returns new orthogonal modes that </span>
<span class="sd">        are reweighted combinations of previous modes. NOTE: should only be</span>
<span class="sd">        applied to modes that have the same eigenvalue, i.e., on the </span>
<span class="sd">        eigensphere.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        modes : np.ndarray of (n_vertices, mu)</span>
<span class="sd">            Orthogonal vectors of n_vertices and mu modes</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_modes : np.ndarray of (n_vertices, mu)</span>
<span class="sd">            Array containing resampled vectors for each pair.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">mu</span> <span class="o">=</span> <span class="n">emodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new_modes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">emodes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        
        <span class="c1"># Derive coefficients</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mu</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
                <span class="n">coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rs</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
                <span class="n">coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rs</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mu</span><span class="p">,))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported distribution </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">distribution</span><span class="p">)))</span>
        
            <span class="c1"># now combine with new coefficients</span>
            <span class="n">new_mode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">emodes</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">)</span>
            <span class="n">new_modes</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_mode</span>
                
        <span class="k">return</span> <span class="n">new_modes</span></div>

<div class="viewcode-block" id="SurfaceEigenstrapping.plot_data"><a class="viewcode-back" href="../../generated/eigenstrapping.SurfaceEigenstrapping.html#eigenstrapping.SurfaceEigenstrapping.plot_data">[docs]</a>    <span class="k">def</span> <span class="nf">plot_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="s1">&#39;lateral&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots a data map using nilearn.plotting, returns fig and ax handles</span>
<span class="sd">        from matplotlib.pyplot for further use. Can also plot values on the</span>
<span class="sd">        surface by input to `data`.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        surface : nib.GiftiImage class or np.ndarray of shape (n_vertices, 3)</span>
<span class="sd">            A single surface to plot.</span>
<span class="sd">        data : np.ndarray of shape (n_vertices,)</span>
<span class="sd">            Data to plot on the surface</span>
<span class="sd">        hemi : str, optional</span>
<span class="sd">            Which hemisphere to plot. The default is &#39;left&#39;.</span>
<span class="sd">        view : str, optional</span>
<span class="sd">            Which view to look at the surface. </span>
<span class="sd">            The default is &#39;lateral&#39;. Accepted strings are detailed in</span>
<span class="sd">            the docs for nilearn.plotting</span>
<span class="sd">        cmap : str or matplotlib.cm class</span>
<span class="sd">            Which colormap to plot the surface with, default is &#39;viridis&#39;</span>
<span class="sd">        show : bool, optional</span>
<span class="sd">            Flag whether to show the plot, default is True</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : figure handle    </span>
<span class="sd">        ax : axes handle</span>
<span class="sd">    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make figure</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">9</span><span class="p">),</span> <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">surface</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        
        <span class="c1"># get colormap</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            
        <span class="c1"># plot surface</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">plotting</span><span class="o">.</span><span class="n">plot_surf</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">surf_map</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="n">hemi</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="n">view</span><span class="p">,</span> 
                           <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                           <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="mi">7</span>
        
        <span class="c1"># show figure check</span>
        <span class="k">if</span> <span class="n">show</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>
        
    
<div class="viewcode-block" id="SurfaceEigenstrapping.eigen_spectrum"><a class="viewcode-back" href="../../generated/eigenstrapping.SurfaceEigenstrapping.html#eigenstrapping.SurfaceEigenstrapping.eigen_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">eigen_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the modal decomposition power spectrum reconstruction using original</span>
<span class="sd">        modes. See ``eigen_decomposition()``. Returns fig and ax handles from </span>
<span class="sd">        matplotlib.pyplot for further use.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : np.ndarray of shape (n_vertices,)</span>
<span class="sd">            Data to decompose and reconstruct for eigen spectrum.</span>
<span class="sd">        show : bool, optional</span>
<span class="sd">            Flag whether to show plot, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.pyplot class</span>
<span class="sd">            Figure handle</span>
<span class="sd">        ax : matplotlib.pyplot class</span>
<span class="sd">            Axes handle</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># compute power spectrum = eval^2</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">eigen_decomposition</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span><span class="p">)</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">normalized_power</span> <span class="o">=</span> <span class="n">power</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
        
        <span class="c1"># now do figure</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">()</span>
        
        <span class="n">ax</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">normalized_power</span><span class="p">)</span>
        <span class="c1">#ax.set_ylim((0.00000, 0.1))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Mode&#39;</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span><span class="mi">30</span><span class="p">})</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Normalized power (log scale)&#39;</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span><span class="mi">30</span><span class="p">})</span>
        
        <span class="c1"># show figure check</span>
        <span class="k">if</span> <span class="n">show</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div></div>
    
<div class="viewcode-block" id="VolumetricEigenstrapping"><a class="viewcode-back" href="../../generated/eigenstrapping.VolumetricEigenstrapping.html#eigenstrapping.VolumetricEigenstrapping">[docs]</a><span class="k">class</span> <span class="nc">VolumetricEigenstrapping</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the eigenmodes and eigenvalues of the volume in `volume` and </span>
<span class="sd">    resample the hypersphere bounded by the eigengroups contained within `emodes`,</span>
<span class="sd">    to reconstruct the data using coefficients conditioned on the original data</span>
<span class="sd">    Based on the degenerate solutions of solving the Laplace-Beltrami operator </span>
<span class="sd">    on the cortex. The power spectrum is perfectly retained (the square of the </span>
<span class="sd">    eigenvalues). If evals and emodes are given (i.e., precomputed) then </span>
<span class="sd">    eigenmodes are not computed. Performs amplitude adjustment by default (see</span>
<span class="sd">    `resample`)</span>
<span class="sd">    </span>
<span class="sd">    @author: Nikitas C. Koussis, School of Psychological Sciences,</span>
<span class="sd">             University of Newcastle &amp; Systems Neuroscience Group Newcastle</span>
<span class="sd">             </span>
<span class="sd">             Michael Breakspear, School of Psychological Sciences,</span>
<span class="sd">             University of Newcastle &amp; Systems Neuroscience Group Newcastle</span>
<span class="sd">             </span>
<span class="sd">    IMPORTANT</span>
<span class="sd">    ---------</span>
<span class="sd">        Several software packages must be installed apart from python dependencies</span>
<span class="sd">        to use this class:</span>
<span class="sd">            - FreeSurfer &gt;5</span>
<span class="sd">            - Gmsh</span>
<span class="sd">            - fsl &gt;5 (if ``aseg`` not passed)</span>
<span class="sd">    </span>
<span class="sd">    Process</span>
<span class="sd">    -------</span>
<span class="sd">        - the orthonormal eigenvectors n within eigengroup l give the surface </span>
<span class="sd">            of the hyperellipse of dimensions l-1</span>
<span class="sd">            NOTE: for eigengroup 0 with the zeroth mode, we ignore it,</span>
<span class="sd">            and for eigengroup 1, this is resampling the surface of the </span>
<span class="sd">            2-sphere</span>
<span class="sd">        - the axes of the hyperellipse are given by the sqrt of the eigenvalues </span>
<span class="sd">            corresponding to eigenvectors n</span>
<span class="sd">        - linear transform the eigenvectors N to the hypersphere by dividing </span>
<span class="sd">            by the ellipsoid axes</span>
<span class="sd">        - finds the set of points `p` on the hypersphere given by the basis </span>
<span class="sd">            modes (the eigenmodes) by normalizing them to unit length</span>
<span class="sd">        - rotate the set of points `p` by cos(angle) for </span>
<span class="sd">            even dimensions and sin(angle) for odd dims (resampling step)</span>
<span class="sd">        - find the unit vectors of the points `p` by dividing by the </span>
<span class="sd">            Euclidean norm (equivalent to the eigenmodes)</span>
<span class="sd">        - make the new unit vectors orthonormal using Gram-Schmidt process</span>
<span class="sd">        - return the new eigenmodes of that eigengroup until all eigengroups</span>
<span class="sd">            are computed</span>
<span class="sd">        - reconstruct the null data by multiplying the original coefficients</span>
<span class="sd">            by the new eigenmodes</span>
<span class="sd">        - resamples the null data by performing rank-ordering to replicate</span>
<span class="sd">            the reconstructed data term, then adds the noise term back into the</span>
<span class="sd">            null data to produce a surrogate that replicates the original</span>
<span class="sd">            variance of the empirical data.</span>
<span class="sd">            * Only performed if `resample` = True.</span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">        1. Robinson, P. A. et al., (2016), Eigenmodes of brain activity: Neural field </span>
<span class="sd">        theory predictions and comparison with experiment. NeuroImage 142, 79-98.</span>
<span class="sd">        &lt;https://dx.doi.org/10.1016/j.neuroimage.2016.04.050&gt;</span>
<span class="sd">        </span>
<span class="sd">        2. Jorgensen, M., (2014), Volumes of n-dimensional spheres and ellipsoids. </span>
<span class="sd">        &lt;https://www.whitman.edu/documents/Academics/Mathematics/2014/jorgenmd.pdf&gt;</span>
<span class="sd">        </span>
<span class="sd">        3. &lt;https://math.stackexchange.com/questions/3316373/ellipsoid-in-n-dimension&gt;</span>
<span class="sd">        </span>
<span class="sd">        4. Blumenson, L. E. (1960). A derivation of n-dimensional spherical </span>
<span class="sd">        coordinates. The American Mathematical Monthly, 67(1), 63-66.</span>
<span class="sd">        &lt;https://www.jstor.org/stable/2308932&gt;</span>
<span class="sd">        </span>
<span class="sd">        5. Trefethen, Lloyd N., Bau, David III, (1997). Numerical linear algebra. </span>
<span class="sd">        Philadelphia, PA: Society for Industrial and Applied Mathematics. </span>
<span class="sd">        ISBN 978-0-898713-61-9.</span>
<span class="sd">        </span>
<span class="sd">        6. https://en.wikipedia.org/wiki/QR_decomposition</span>
<span class="sd">        </span>
<span class="sd">        7. Chen, Y. C. et al., (2022). The individuality of shape asymmetries </span>
<span class="sd">        of the human cerebral cortex. Elife, 11, e75056. </span>
<span class="sd">        &lt;https://doi.org/10.7554/eLife.75056&gt;</span>
<span class="sd">        </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    volume : str to image</span>
<span class="sd">        Filename of volume ROI with integer intensity values. Must be in the same</span>
<span class="sd">        space (i.e. registered) to the volume file in `data`. Extensions</span>
<span class="sd">        are those commonly accepted by nibabel (see nibabel file types). Volume</span>
<span class="sd">        is extracted using FreeSurfer or fslmaths if ``aseg`` is not passed.</span>
<span class="sd">        </span>
<span class="sd">    data : str to image or str to text file</span>
<span class="sd">        Filename of empirical data to resample</span>
<span class="sd">        </span>
<span class="sd">    label : int or list of ints or array of ints, optional</span>
<span class="sd">        Label of value in ``volume`` for ROI extraction. If default None, volume</span>
<span class="sd">        is considered to be a mask - i.e., all values equal to 1 are extracted</span>
<span class="sd">        and transformed to tetrahedral space, and those equal to 0 or otherwise </span>
<span class="sd">        are left out. Default is None</span>
<span class="sd">        </span>
<span class="sd">    aseg : bool, optional</span>
<span class="sd">        Specify whether file in ``volume`` is FreeSurfer preprocessed &quot;aseg.mgz&quot;</span>
<span class="sd">        file. Extra steps need to be performed for computation, though labels</span>
<span class="sd">        can be combined into structures (e.g., ``label=[11, 12, 26]`` with </span>
<span class="sd">        ``aseg=True`` would combine the left caudate, left putamen, and left NA</span>
<span class="sd">        to make the left striatum. See the FreeSurferColorLUT.txt for more</span>
<span class="sd">        details about labeling). Default is False</span>
<span class="sd">        </span>
<span class="sd">    evals : np.ndarray of shape (n,), optional</span>
<span class="sd">        Eigenvalues corresponding to the number of eigenmodes n in `emodes`.</span>
<span class="sd">        Default is None</span>
<span class="sd">        </span>
<span class="sd">    emodes : np.ndarray of shape (n_vertices, n), optional</span>
<span class="sd">        Eigenmodes that are the solution to the generalized eigenvalue problem</span>
<span class="sd">        or Helmholtz equation in the Laplace-Beltrami operator of the volume</span>
<span class="sd">        (must be in tetrahedral space). Default is None</span>
<span class="sd">        </span>
<span class="sd">    num_modes : int, optional</span>
<span class="sd">        If `evals` and `emodes` are not given, then they are computed on the</span>
<span class="sd">        surface given in `surface`. This variable controls how many modes</span>
<span class="sd">        to compute. Cannot exceed the number of vertices after tetrahedral</span>
<span class="sd">        resampling of ``volume``.</span>
<span class="sd">        Default is 200.</span>
<span class="sd">    </span>
<span class="sd">    seed : None or int or np.random.RandomState instance</span>
<span class="sd">        Specify the seed for random angle generation (or random state instance)</span>
<span class="sd">        default None.</span>
<span class="sd">        </span>
<span class="sd">    decomp_method : str, optional</span>
<span class="sd">        method of calculation of coefficients: &#39;matrix&#39;, &#39;matrix_separate&#39;, </span>
<span class="sd">        &#39;regression&#39;.</span>
<span class="sd">        </span>
<span class="sd">        The default is &#39;matrix&#39;.</span>
<span class="sd">        </span>
<span class="sd">    resample : bool, optional</span>
<span class="sd">        Set whether to resample surrogate map from original map to preserve</span>
<span class="sd">        values, default True</span>
<span class="sd">        </span>
<span class="sd">    randomize : bool, optional</span>
<span class="sd">        Set whether to shuffle coefficients calculated from minimizing</span>
<span class="sd">        least-squares error to reconstruct surrogates. Results in better</span>
<span class="sd">        randomization of surrogates at the cost of poorer replication of</span>
<span class="sd">        empirical spatial autocorrelation.</span>
<span class="sd">    </span>
<span class="sd">    n_jobs : int, optional</span>
<span class="sd">        Number of workers to use for parallelization. Default 1.</span>
<span class="sd">        </span>
<span class="sd">    use_cholmod : bool, optional</span>
<span class="sd">        Specify whether or not to use sksparse subroutines - requires </span>
<span class="sd">        ``scikit-sparse`` and ``libsuitesparse-dev`` to be installed. See </span>
<span class="sd">        https://github.com/scikit-sparse/scikit-sparse for more information.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError : Inappropriate inputs</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aseg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">norm_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">normalization</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalization_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">evals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">emodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_modes</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decomp_method</span><span class="o">=</span><span class="s1">&#39;matrix&#39;</span><span class="p">,</span> 
                 <span class="n">randomize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">permute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        
        <span class="c1"># checks</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_string_like</span><span class="p">(</span><span class="n">volume</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input volume must be filename&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">voldir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nifti_input_tail</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nifti_input_main</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nifti_input_ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nifti_input_tail</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_string_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_input_head</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_input_tail</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_input_main</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_input_ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_input_tail</span><span class="p">)</span>
       
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ROI</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROI</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROI</span><span class="o">.</span><span class="n">affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roi</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roi</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">affines</span><span class="o">.</span><span class="n">apply_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_cholmod</span> <span class="o">=</span> <span class="kc">False</span>
                     
        <span class="k">if</span> <span class="n">is_string_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_input_ext</span> <span class="o">==</span> <span class="s1">&#39;.txt&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span> <span class="o">=</span> <span class="n">masking</span><span class="o">.</span><span class="n">unmask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROI</span><span class="p">)</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">Nifti1Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ROI</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span><span class="o">.</span><span class="n">affine</span><span class="p">,</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">affine</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input volume and input data must have the same affine transformation (i.e., be in the same space&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">new_data</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">Nifti1Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()[:,:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">affine</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span> <span class="o">=</span> <span class="n">masking</span><span class="o">.</span><span class="n">unmask</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROI</span><span class="p">)</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm_file</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="mi">1</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roi_number</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_vol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">decomp_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rs</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span> <span class="o">=</span> <span class="n">randomize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resample</span> <span class="o">=</span> <span class="n">resample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">permute</span> <span class="o">=</span> <span class="n">permute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        
        <span class="c1"># prepare data and masking</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inds_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roi</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inds_all</span>
        
        <span class="k">if</span> <span class="n">normalization</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">normalization</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">norm_types</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Normalization type must be &quot;area&quot;, &quot;constant&quot;, &quot;volume&quot;, or &quot;number&quot;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">normalization</span> <span class="o">==</span> <span class="s1">&#39;constant&#39;</span> <span class="ow">and</span> <span class="n">normalization_factor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Normalization type of &quot;constant&quot; but no factor given&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_type</span> <span class="o">=</span> <span class="n">normalization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span> <span class="o">=</span> <span class="n">normalization_factor</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">masked_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
        
        
        <span class="c1"># prepare tetra surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tetra_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_tetra</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="c1"># get transform matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">get_tkrvox2ras</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ROI</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROI</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">get_zooms</span><span class="p">())</span>
        
        <span class="c1"># apply transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
        
        <span class="c1"># load surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tetra</span> <span class="o">=</span> <span class="n">TetMesh</span><span class="o">.</span><span class="n">read_vtk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tetra_file</span><span class="p">)</span>
        
        <span class="c1"># calculate number and volume</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roi_number</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_volume</span><span class="p">()</span>
        
        <span class="c1"># normalize surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tetra_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_vtk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tetra</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">num_modes</span> <span class="o">=</span> <span class="n">num_modes</span>
        
        <span class="k">if</span> <span class="n">emodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_volume_eigenmodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tetra_norm</span><span class="p">,</span> 
                                        <span class="bp">self</span><span class="o">.</span><span class="n">num_modes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cholmod</span><span class="p">)</span>
            <span class="c1"># remove zeroth mode</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
    
        <span class="c1"># reconstruct data in tetrahedral space</span>
        <span class="c1">#self.tetra_data = self.project_to_tetra(self.tetra, self.masked_data)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emodes</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">=</span> <span class="n">eigen_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masked_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstructed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstructed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstructed_data</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked_data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstructed_data</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="o">=</span> <span class="n">compute_psd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masked_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span><span class="p">)</span>
        <span class="c1"># find eigengroups</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">_get_eigengroups</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lm</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">(</span><span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate new surrogate map(s) in tetra space. Resample using </span>
<span class="sd">        ``.resample_data(surrs)``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, optional</span>
<span class="sd">            Number of surrogates to generate. The default is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (n,N) np.ndarray</span>
<span class="sd">            Generated map(s) resampled from eigenspace of tetrahedral surface</span>
<span class="sd">            </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Surrogates are in tetrahedral surface space. They will need to be</span>
<span class="sd">        resampled to volumetric space with ``.resample_data(surrs)``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">rs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rs</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="n">surrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">(</span>
            <span class="n">Parallel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)(</span>
                <span class="n">delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_call_method</span><span class="p">)(</span><span class="n">rs</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rs</span>
            <span class="p">)</span>
        <span class="p">)</span>        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">surrs</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
    
    <span class="k">def</span> <span class="nf">_call_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># reset randomstate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rs</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>
        
        <span class="n">surrogate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">surrogate</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    
<div class="viewcode-block" id="VolumetricEigenstrapping.rotate_modes"><a class="viewcode-back" href="../../generated/eigenstrapping.VolumetricEigenstrapping.html#eigenstrapping.VolumetricEigenstrapping.rotate_modes">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_modes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emodes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate modes using random rotations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vectors : np.ndarray of (n_vertices, mu)</span>
<span class="sd">            Orthogonal vectors of n_vertices and mu modes</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotated_vectors : np.ndarray of (n_vertices, mu)</span>
<span class="sd">            Array containing rotated vectors for each pair.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">rotate_matrix</span><span class="p">(</span><span class="n">emodes</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="VolumetricEigenstrapping.generate"><a class="viewcode-back" href="../../generated/eigenstrapping.VolumetricEigenstrapping.html#eigenstrapping.VolumetricEigenstrapping.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_modes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate eigensphere resampled surrogate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_modes : bool, optional</span>
<span class="sd">            Output resampled modes for debugging. The default is False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (n,) : np.ndarray</span>
<span class="sd">            Surrogate data in tetrahedral space</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># initialize data</span>
        <span class="n">emodes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_emodes</span><span class="p">)</span>
        <span class="n">evals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evals</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">)</span>
        <span class="n">reconstructed_data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reconstructed_data</span><span class="p">)</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residuals</span><span class="p">)</span>
        
        <span class="c1"># initialize the new modes</span>
        <span class="n">new_modes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">emodes</span><span class="p">)</span>
        
        <span class="c1"># resample the hypersphere</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)):</span>
            <span class="n">group_modes</span> <span class="o">=</span> <span class="n">emodes</span><span class="p">[:,</span> <span class="n">groups</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
            <span class="n">group_evals</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">groups</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
            
            <span class="c1"># else, transform to spheroid and index the angles properly</span>
            <span class="n">group_new_modes</span> <span class="o">=</span> <span class="n">transform_to_spheroid</span><span class="p">(</span><span class="n">group_evals</span><span class="p">,</span> <span class="n">group_modes</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">group_new_modes</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">group_modes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_modes</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            
            <span class="c1"># transform back to ellipsoid</span>
            <span class="n">group_ellipsoid_modes</span> <span class="o">=</span> <span class="n">transform_to_ellipsoid</span><span class="p">(</span><span class="n">group_evals</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            
            <span class="n">new_modes</span><span class="p">[:,</span> <span class="n">groups</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">group_ellipsoid_modes</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">group_ellipsoid_modes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
        
        <span class="k">if</span> <span class="n">output_modes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_modes</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)):</span>
                <span class="n">coeffs</span><span class="p">[</span><span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rs</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                
        <span class="n">surrogate</span> <span class="o">=</span> <span class="n">coeffs</span> <span class="o">@</span> <span class="n">new_modes</span><span class="o">.</span><span class="n">T</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">:</span>
            <span class="n">data_ranks</span> <span class="o">=</span> <span class="n">reconstructed_data</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">surr_ranks</span> <span class="o">=</span> <span class="n">surrogate</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="n">surrogate</span><span class="p">[</span><span class="n">surr_ranks</span><span class="p">]</span> <span class="o">=</span> <span class="n">reconstructed_data</span><span class="p">[</span><span class="n">data_ranks</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">permute</span><span class="p">:</span>
            <span class="n">surrogate</span> <span class="o">=</span> <span class="n">surrogate</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rs</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">surrogate</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="VolumetricEigenstrapping.resample_data"><a class="viewcode-back" href="../../generated/eigenstrapping.VolumetricEigenstrapping.html#eigenstrapping.VolumetricEigenstrapping.resample_data">[docs]</a>    <span class="k">def</span> <span class="nf">resample_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample data on tetrahedral surface to volumetric space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : np.ndarray of shape (n_tetra_points, N)</span>
<span class="sd">            Data to resample</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Interpolation method for ``scipy.interpolate.griddata``. </span>
<span class="sd">            The default is &#39;linear&#39;.</span>
<span class="sd">        vector : bool, optional</span>
<span class="sd">            Resample data to masked vector (values inside ROI only). Default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        resampled_data : np.ndarray of shape (A,B,C,N)</span>
<span class="sd">            Data in volumetric space.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">points_surface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tetra</span><span class="o">.</span><span class="n">v</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roi</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">new_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="n">data_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        
        <span class="c1"># perform interpolation of data from tetrahedral space to volume space</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">interpolated_data</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">points_surface</span><span class="p">,</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points_trans</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
            <span class="n">data_vec</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolated_data</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">interpolated_data</span><span class="p">)):</span>
                <span class="n">new_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xx</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">yy</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">zz</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span> <span class="o">=</span> <span class="n">interpolated_data</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">vector</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data_vec</span>
        
        <span class="k">return</span> <span class="n">new_data</span></div>
        
<div class="viewcode-block" id="VolumetricEigenstrapping.project_to_tetra"><a class="viewcode-back" href="../../generated/eigenstrapping.VolumetricEigenstrapping.html#eigenstrapping.VolumetricEigenstrapping.project_to_tetra">[docs]</a>    <span class="k">def</span> <span class="nf">project_to_tetra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetra</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Project data in volumetric space onto tetrahedral surface.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tetra : lapy compatible object</span>
<span class="sd">            Loaded object corresponding to tetrahedral surface.</span>
<span class="sd">        data : np.ndarray of shape (xx, yy, zz)</span>
<span class="sd">            Data to project to tetrahedral surface with values inside ROI.</span>
<span class="sd">        interpolation : str, optional</span>
<span class="sd">            Interpolation kind. Default is &#39;linear&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tetra_data : np.ndarray of shape (number of tetra points,)</span>
<span class="sd">            Resampled data</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">tetra</span><span class="o">.</span><span class="n">v</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span>
        
        <span class="n">tetra_data</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> 
                              <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># points_orig = T @ points.T</span>
        <span class="c1"># points_orig = points_orig.T[:,:3]</span>
        <span class="c1"># mesh = (points_orig, t)</span>
        <span class="c1"># tetra_data = s.vol_to_surf(</span>
        <span class="c1">#     data, mesh, interpolation=&#39;nearest&#39;, radius=3, kind=&#39;ball&#39;)</span>
        
        <span class="k">return</span> <span class="n">tetra_data</span></div>
        
    
<div class="viewcode-block" id="VolumetricEigenstrapping.make_tetra"><a class="viewcode-back" href="../../generated/eigenstrapping.VolumetricEigenstrapping.html#eigenstrapping.VolumetricEigenstrapping.make_tetra">[docs]</a>    <span class="k">def</span> <span class="nf">make_tetra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aseg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate tetrahedral version of the ROI in the nifti file. Can</span>
<span class="sd">        specify label value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        volume : str</span>
<span class="sd">            Filename of input volume where the relevant ROI has voxel </span>
<span class="sd">            values = 1 or ``label``</span>
<span class="sd">        label : int or list of ints, optional</span>
<span class="sd">            Label value(s) of input volume. Extracts surface from voxels that have</span>
<span class="sd">            this(ese) intensity value(s). If None, defaults to 1</span>
<span class="sd">        aseg : bool, optional</span>
<span class="sd">            Specify whether input volume and label is from FreeSurfer</span>
<span class="sd">            aseg.nii.gz (post-FS preprocessing).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tetra_file : str</span>
<span class="sd">            Filename of output tetrahedral vtk file</span>
<span class="sd">            </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            Multiple labels given but aseg not passed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="n">make_tetra</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">aseg</span><span class="o">=</span><span class="n">aseg</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="VolumetricEigenstrapping.calc_volume_eigenmodes"><a class="viewcode-back" href="../../generated/eigenstrapping.VolumetricEigenstrapping.html#eigenstrapping.VolumetricEigenstrapping.calc_volume_eigenmodes">[docs]</a>    <span class="k">def</span> <span class="nf">calc_volume_eigenmodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetra</span><span class="p">,</span> <span class="n">num_modes</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">use_cholmod</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the eigenvalues and eigenmodes of the ROI volume.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tetra : lapy compatible object</span>
<span class="sd">            Loaded lapy object corresponding to tetrahedral surface of ROI in vtk format</span>
<span class="sd">        num_modes : int, optional</span>
<span class="sd">            Number of eigenmodes to compute. The default is 200</span>
<span class="sd">        use_cholmod : bool, optional</span>
<span class="sd">            Specify whether to use ``scikit-sparse`` libraries to compute eigenmodes.</span>
<span class="sd">            Much faster but requires libraries to be installed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        evals : np.ndarray of shape (num_modes,)</span>
<span class="sd">            Eigenvalues</span>
<span class="sd">        emodes : np.ndarray of shape (number of tetra points, num_modes)</span>
<span class="sd">            Eigenmodes</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># calc eigenmodes and eigenvalues</span>
        <span class="n">fem</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">tetra</span><span class="p">)</span>
        <span class="n">evals</span><span class="p">,</span> <span class="n">emodes</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">eigs</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">num_modes</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">evals</span><span class="p">,</span> <span class="n">emodes</span></div>
    
<div class="viewcode-block" id="VolumetricEigenstrapping.calc_volume"><a class="viewcode-back" href="../../generated/eigenstrapping.VolumetricEigenstrapping.html#eigenstrapping.VolumetricEigenstrapping.calc_volume">[docs]</a>    <span class="k">def</span> <span class="nf">calc_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nifti_volume</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the physical volume of the ROI in the nifti file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nifti_volume : str, optional</span>
<span class="sd">            Filename of input volume in nifti format</span>
<span class="sd">        label : int, optional</span>
<span class="sd">            Label value for input ROI in ``nifti_volume``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ROI_number : int</span>
<span class="sd">            Total number of non-zero voxels</span>
<span class="sd">        ROI_volume : float</span>
<span class="sd">            Total volume of non-zero voxels in physical dimensions</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nifti_volume</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roi</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">nifti_volume</span><span class="p">)</span>
            <span class="n">roi_data</span> <span class="o">=</span> <span class="n">roi</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">roi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROI</span>
            <span class="n">roi_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi</span>
        
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="n">roi_data</span> <span class="o">=</span> <span class="n">roi_data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">roi_data</span><span class="o">==</span><span class="n">label</span><span class="p">)]</span>
        
        <span class="c1"># get voxel dimensions in mm</span>
        <span class="n">voxel_dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">roi</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;pixdim&quot;</span><span class="p">])[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">voxel_vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">voxel_dims</span><span class="p">)</span>
        
        <span class="c1"># compute volume</span>
        <span class="n">ROI_number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">roi_data</span><span class="p">)</span>
        <span class="n">ROI_volume</span> <span class="o">=</span> <span class="n">ROI_number</span> <span class="o">*</span> <span class="n">voxel_vol</span>        
        
        <span class="k">return</span> <span class="n">ROI_number</span><span class="p">,</span> <span class="n">ROI_volume</span></div>
    
<div class="viewcode-block" id="VolumetricEigenstrapping.normalize_vtk"><a class="viewcode-back" href="../../generated/eigenstrapping.VolumetricEigenstrapping.html#eigenstrapping.VolumetricEigenstrapping.normalize_vtk">[docs]</a>    <span class="k">def</span> <span class="nf">normalize_vtk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetra</span><span class="p">,</span> <span class="n">normalization_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalization_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize tetrahedral surface</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tetra : lapy compatible object</span>
<span class="sd">            Loaded vtk object corresponding to a surface tetrahedral mesh</span>
<span class="sd">        normalization_type : str or None, optional</span>
<span class="sd">            Type of normalization. The default is None.</span>
<span class="sd">        normalization_factor : float or None, optional</span>
<span class="sd">            Factor to be used in &quot;constant&quot; normalization. The default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tetra_norm : lapy compatible object</span>
<span class="sd">            Loaded vtk object corresponding to normalized tetrahedral surface</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tetra_norm</span> <span class="o">=</span> <span class="n">tetra</span>
        <span class="k">if</span> <span class="n">normalization_type</span> <span class="o">==</span> <span class="s1">&#39;number&#39;</span><span class="p">:</span>
            <span class="n">tetra_norm</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">tetra</span><span class="o">.</span><span class="n">v</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_number</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">normalization_type</span> <span class="o">==</span> <span class="s1">&#39;volume&#39;</span><span class="p">:</span>
            <span class="n">tetra_norm</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">tetra</span><span class="o">.</span><span class="n">v</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_volume</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">normalization_type</span> <span class="o">==</span> <span class="s1">&#39;area&#39;</span><span class="p">:</span>
            <span class="n">tetra_norm</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">tetra</span><span class="o">.</span><span class="n">v</span><span class="o">/</span><span class="p">(</span><span class="n">tetra</span><span class="o">.</span><span class="n">vertex_areas</span><span class="p">()</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
        
        <span class="k">if</span> <span class="n">normalization_type</span> <span class="ow">in</span> <span class="n">norm_types</span><span class="p">:</span>
            <span class="n">surface_output_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voldir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nifti_input_main</span> <span class="o">+</span> <span class="s1">&#39;_norm=&#39;</span> <span class="o">+</span> <span class="n">normalization_type</span> <span class="o">+</span> <span class="s1">&#39;.tetra.vtk&#39;</span><span class="p">)</span>
    
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">surface_output_fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;# vtk DataFile Version 2.0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nifti_input_tail</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;ASCII</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;DATASET POLYDATA</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;POINTS &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tetra</span><span class="o">.</span><span class="n">v</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; float</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tetra</span><span class="o">.</span><span class="n">v</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">tetra_norm</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;POLYGONS &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tetra</span><span class="o">.</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tetra</span><span class="o">.</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tetra</span><span class="o">.</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">tetra</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">tetra_norm</span></div>
    
<div class="viewcode-block" id="VolumetricEigenstrapping.eigen_spectrum"><a class="viewcode-back" href="../../generated/eigenstrapping.VolumetricEigenstrapping.html#eigenstrapping.VolumetricEigenstrapping.eigen_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">eigen_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the modal decomposition power spectrum. See ``geometry.eigen_decomposition()``</span>
<span class="sd">        Returns fig and ax handles from matplotlib.pyplot for further use.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        show : bool, optional</span>
<span class="sd">            Flag whether to show plot, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.pyplot class</span>
<span class="sd">            Figure handle</span>
<span class="sd">        ax : matplotlib.pyplot class</span>
<span class="sd">            Axes handle</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># compute power spectrum = eval^2</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">eigen_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tetra_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emodes</span><span class="p">)</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">normalized_power</span> <span class="o">=</span> <span class="n">power</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
        
        <span class="c1"># now do figure</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">()</span>
        
        <span class="n">ax</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">normalized_power</span><span class="p">)</span>
        <span class="c1">#ax.set_ylim((0.00000, 0.1))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Mode&#39;</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span><span class="mi">30</span><span class="p">})</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Normalized power (log scale)&#39;</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span><span class="mi">30</span><span class="p">})</span>
        
        <span class="c1"># show figure check</span>
        <span class="k">if</span> <span class="n">show</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>
    
<div class="viewcode-block" id="VolumetricEigenstrapping.calculate_distance_matrix"><a class="viewcode-back" href="../../generated/eigenstrapping.VolumetricEigenstrapping.html#eigenstrapping.VolumetricEigenstrapping.calculate_distance_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_distance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates Euclidean distance matrix and index memmap files of ROI,</span>
<span class="sd">        also returns data masked by ROI.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outdir : str, optional</span>
<span class="sd">            Output directory of distance and index np.memmap files.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        masked_data : (N,)</span>
<span class="sd">            </span>
<span class="sd">        dist : np.memmap</span>
<span class="sd">            Distance memmap matrix.</span>
<span class="sd">        index : str</span>
<span class="sd">            Distance index memmap matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>
        
        <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span>
        <span class="c1">#xyz = self.inds_all</span>
        <span class="n">distout</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;.mmap&#39;</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">distout</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                         <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xyz</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xyz</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">indout</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;.mmap&#39;</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">indout</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                         <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xyz</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xyz</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
        
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xyz</span><span class="p">):</span>
            <span class="n">xyz_dist</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">xyz</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="n">index</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xyz_dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz_dist</span><span class="p">[:,</span> <span class="n">index</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
            <span class="n">dist</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="n">index</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>       
        
        <span class="n">masked_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">return_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">masked_data</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">index</span>
            
        <span class="k">return</span> <span class="n">dist</span><span class="p">,</span> <span class="n">index</span></div>
    
<div class="viewcode-block" id="VolumetricEigenstrapping.surfplot"><a class="viewcode-back" href="../../generated/eigenstrapping.VolumetricEigenstrapping.html#eigenstrapping.VolumetricEigenstrapping.surfplot">[docs]</a>    <span class="k">def</span> <span class="nf">surfplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="s1">&#39;dorsal&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">vrange</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plotting helper function for volumetric data to triangular</span>
<span class="sd">        surfaces.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : np.ndarray of shape (n_vertices,)</span>
<span class="sd">            Volumetric data projected to tetrahedral mesh. See self.project_to_tetra().</span>
<span class="sd">        view : str or pair of float, optional</span>
<span class="sd">            Specify which direction to place camera and view from. See </span>
<span class="sd">            ``nilearn.plotting.plot_surf()`` for accepted strings. If pair of</span>
<span class="sd">            float, must be a list or tuple of (elevation, azimuthal) of angles</span>
<span class="sd">            in degrees. The default is &#39;dorsal&#39;.</span>
<span class="sd">        cmap : str, optional</span>
<span class="sd">            Colormap for values in ``data``. Must be in matplotlib colormaps.</span>
<span class="sd">            The default is &#39;viridis&#39;</span>
<span class="sd">        vrange : tuple of two floats, optional</span>
<span class="sd">            Range to truncate minimum and maximum values. The default is [-4, 4].</span>
<span class="sd">        annotations : bool, optional</span>
<span class="sd">            Specify whether to add annotation labels for direction etc</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.pyplot.Figure handle</span>
<span class="sd">        ax : matplotlib.pyplot.Axes handle</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># define mesh</span>
        <span class="n">tria</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tria</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="p">(</span><span class="n">tria</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="n">tria</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span>
        <span class="n">tria_data</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">tria</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        
        <span class="c1"># get colormap</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vrange</span>
        
        <span class="c1"># define figure</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.97</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">plotting</span><span class="o">.</span><span class="n">plot_surf</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">tria_data</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="n">view</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
                           <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        
        <span class="n">cax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">([</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">])</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">),</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">vmax</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span><span class="mi">20</span><span class="p">},</span> <span class="n">pad</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">vmin</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span><span class="mi">20</span><span class="p">},</span> <span class="n">labelpad</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
            
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div></div>
        
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, eigenstrapping devs.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>